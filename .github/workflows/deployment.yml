name: Multi-Environment Deployment Pipeline

on:
  pull_request:
    types:
    - closed
    paths-ignore:
    - 'VERSION'
    branches:
    - dev
  push:
    branches:
    - prod
    - dev
    - staging
    paths-ignore:
    - 'VERSION'
    - 'README.md'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write
  security-events: write

env:
  NODE_VERSION: 20
  AWS_REGION: us-west-2

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      releaseTrue: ${{steps.release-status.outputs.rel-status}}
      currentVersion: ${{ steps.updated-version.outputs.version }}
      currentENV: ${{ steps.current-env.outputs.ENV }}
      imageTag: ${{ steps.build-image.outputs.image-tag }}
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: app/package-lock.json

    - name: Install Dependencies
      run: |
        cd app
        npm ci

    - name: Run Linting
      run: |
        cd app
        npm run lint

    - name: Run Tests
      run: |
        cd app
        npm test -- --coverage

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        file: ./app/coverage/lcov.info
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false
        token: ${{ secrets.CODECOV_TOKEN }}

    - name: Determine version increment
      id: version-increment
      run: |
        commit_message=$(git log -1 --pretty=%B)
        if [[ "$commit_message" == *"major:"* ]]; then
          echo "increment=major" >> "$GITHUB_OUTPUT"
          echo "release=true" >> "$GITHUB_OUTPUT"
        elif [[ "$commit_message" == "minor:"* ]]; then
          echo "increment=minor" >> "$GITHUB_OUTPUT"
          echo "release=true" >> "$GITHUB_OUTPUT"
        elif [[ "$commit_message" == "patch:"* ]]; then
          echo "increment=patch" >> "$GITHUB_OUTPUT"
          echo "release=true" >> "$GITHUB_OUTPUT"
        else
          echo "release=false" >> "$GITHUB_OUTPUT"
        fi
        
    - name: Publish Release Status
      id: release-status
      run: |
        echo "rel-status=${{ env.release }}" >> "$GITHUB_OUTPUT"
      env:
        release: ${{ steps.version-increment.outputs.release }}

    - name: Publish Current Environment
      id: current-env
      run: |
        export ENVIRONMENT=$(echo "${{ github.ref }}" | sed -e "s/refs\\/heads\\///g")
        echo "ENV=${ENVIRONMENT}" >> "$GITHUB_OUTPUT"

    - name: Get current version
      id: get-version
      run: echo "version=$(cat VERSION)" >> "$GITHUB_OUTPUT"

    - name: Increment version
      id: increment-version
      run: echo "new_version=$(docker run --rm -v ${PWD}:/app treeder/bump ${{ steps.version-increment.outputs.increment }})" >> "$GITHUB_OUTPUT"
      if: |
        github.ref == 'refs/heads/dev' && 
        ${{ steps.version-increment.outputs.release }} == 'true'

    - name: Update VERSION file
      run: echo "${{ steps.increment-version.outputs.new_version }}" > VERSION
      if: |
        github.ref == 'refs/heads/dev' &&
        ${{ steps.version-increment.outputs.release }} == 'true'

    - name: Get updated version
      id: updated-version
      run: echo "version=$(cat VERSION)" >> "$GITHUB_OUTPUT"

    - uses: EndBug/add-and-commit@v9
      name: Commit VERSION file to Dev
      with:
        add: 'VERSION'
        author_name: 'GitHub Actions'
        author_email: 'action@github.com'
        fetch: false
        message: 'Updating VERSION file'
        pathspec_error_handling: ignore
        push: origin dev --force
        tag: "${{ steps.updated-version.outputs.version }} --force"
        tag_push: '--force'
      if: |
        github.ref == 'refs/heads/dev' &&
        ${{ steps.version-increment.outputs.release }} == 'true'

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Docker Build and Push Dev
      id: build-image
      run: |
        cd app
        IMAGE_TAG=${{ secrets.DOCKER_USERNAME }}/node-app:${{ steps.updated-version.outputs.version }}-dev
        docker build -t $IMAGE_TAG .
        docker push $IMAGE_TAG
        echo "image-tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
      if: github.ref == 'refs/heads/dev'

    - name: Docker Build and Push Staging
      run: |
        cd app
        docker build -t ${{ secrets.DOCKER_USERNAME }}/node-app:${{ steps.updated-version.outputs.version }}-staging .
        docker push ${{ secrets.DOCKER_USERNAME }}/node-app:${{ steps.updated-version.outputs.version }}-staging
      if: github.ref == 'refs/heads/staging'

    - name: Docker Build and Push Prod
      run: |
        cd app
        docker build -t ${{ secrets.DOCKER_USERNAME }}/node-app:${{ steps.updated-version.outputs.version }}-prod .
        docker push ${{ secrets.DOCKER_USERNAME }}/node-app:${{ steps.updated-version.outputs.version }}-prod
      if: github.ref == 'refs/heads/prod'

    - name: Notify Slack - Release
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        fields: workflow,job,commit,repo,ref,author,took
        custom_payload: |
          {
            attachments: [{
              color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',
              text: `Workflow: ${process.env.AS_WORKFLOW}\nJob: ${process.env.AS_JOB}\nCommit: ${process.env.AS_COMMIT}\nVersion: ${process.env.AS_VERSION}\nRepository: ${process.env.AS_REPO}@${process.env.AS_REF}\nAuthor: ${process.env.AS_AUTHOR}\nStatus: ${{ job.status }}\nDuration: ${process.env.AS_TOOK}`,
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        AS_VERSION: ${{ steps.updated-version.outputs.version }}
      if: |
        github.ref == 'refs/heads/dev' &&
        ${{ steps.version-increment.outputs.release }} == 'true'

    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        fields: workflow,job,commit,repo,ref,author,took
        custom_payload: |
          {
            attachments: [{
              color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',
              text: `Workflow: ${process.env.AS_WORKFLOW}\nJob: ${process.env.AS_JOB}\nCommit: ${process.env.AS_COMMIT}\nVersion: ${process.env.AS_VERSION}\nRepository: ${process.env.AS_REPO}@${process.env.AS_REF}\nAuthor: ${process.env.AS_AUTHOR}\nStatus: ${{ job.status }}\nDuration: ${process.env.AS_TOOK}`,
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        AS_VERSION: ${{ steps.updated-version.outputs.version }}
      if: ${{ steps.version-increment.outputs.release }} == 'false'

  deployment:
    needs: build
    runs-on: ubuntu-latest

    env:
      TF_IN_AUTOMATION: "1"
      S3_BUCKET: ${{ secrets.S3_BUCKET }}
      S3_REGION: ${{ secrets.S3_REGION }}
      DYNAMODB_TABLE: ${{ secrets.DYNAMODB_TABLE }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
      ENVIRONMENT: ${{ needs.build.outputs.currentENV }}
      TF_VAR_environment: ${{ needs.build.outputs.currentENV }}
      NODE_VERSION: ${{ env.NODE_VERSION }}

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: app/package-lock.json

    - name: Terraform CLI Setup
      uses: hashicorp/setup-terraform@v3

    - name: Install AWS CLI v2
      run: |
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip awscliv2.zip
        sudo ./aws/install --update       
    
    - name: Terraform Init EKS
      run: |
        cd terraform
        terraform init \
          -backend-config="bucket=${S3_BUCKET}" \
          -backend-config="key=state/${ENVIRONMENT}-env.tfstate" \
          -backend-config="region=${S3_REGION}" \
          -backend-config="encrypt=true" \
          -backend-config="dynamodb_table=${DYNAMODB_TABLE}"

    
    - name: Install Kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'latest'

    - name: Configure Kubectl if EKS running
      run: aws eks --region ${{ secrets.S3_REGION }} update-kubeconfig --name e2ecicd-eks-${ENVIRONMENT} || install -m 600 -D /dev/null ~/.kube/config
    
    - name: Terraform Plan EKS
      id: tf-plan-eks
      run: |
        cd terraform
        export exitcode=0
        terraform plan -detailed-exitcode -no-color -out tfplan
        export exitcode=$?

             
        if [ $exitcode -eq 1 ]; then
          echo "Terraform Plan Failed!"
          exit 1
        elif [ $exitcode -eq 2 ]; then
           echo "Drift detected. Need to run terraform apply"
           echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
           exit 0
        else 
          exit 0
        fi

    - name: Deploy EKS Cluster
      run: |
        cd terraform
        terraform apply -auto-approve tfplan
      if: ${{ steps.tf-plan-eks.outputs.exitcode == '2' }}

    - name: Create Namespace
      run: |
        NAMESPACE=app-${ENVIRONMENT}
        kubectl get ns ${NAMESPACE} || kubectl create namespace ${NAMESPACE}

    - name: Update Image
      run: |
        image=${{ secrets.DOCKER_USERNAME }}/node-app:${{ needs.build.outputs.currentVersion }}-${ENVIRONMENT}
        sed -i "s|image: .*$|image: ${image}|" kustomize/overlays/${ENVIRONMENT}/deploy-${ENVIRONMENT}.yaml

    - name: Install Kustomized Manifests
      id: kustomize-deploy
      run: |
        kubectl apply -k kustomize/overlays/${ENVIRONMENT} | tee kubeout
        
        if grep -q "deployment.*unchanged" kubeout; then
          echo "needRestart=yes" >> "$GITHUB_OUTPUT"
        else
          echo "needRestart=no" >> "$GITHUB_OUTPUT"
        fi

    - name: Rollout Restart Deployment
      run: kubectl -n app-${ENVIRONMENT} rollout restart deployment web-deployment
      if: ${{ steps.kustomize-deploy.outputs.needRestart == 'yes' }}

    - name: Get LB hostname
      id: lb-hostname
      run: |
        kubectl -n ingress-nginx get svc ingress-nginx-controller \
          -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' > lb-hostname
          echo -n "hostname=$(cat lb-hostname)" >> "$GITHUB_OUTPUT"
    
    - name: Set DNS on Cloudflare
      uses: rez0n/create-dns-record@v2.1
      with:
        type: "CNAME"
        name: "${{ needs.build.outputs.currentENV }}.afraz.dev"
        content: ${{ steps.lb-hostname.outputs.hostname }}
        ttl: 1
        proxied: true
        token: ${{ secrets.CLOUDFLARE_TOKEN }}
        zone: ${{ secrets.CLOUDFLARE_ZONE }}
   
    - name: Notify Slack - Deployment
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        fields: workflow,job,commit,repo,ref,author,took
        custom_payload: |
          {
            attachments: [{
              color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',
              text: `Workflow: ${process.env.AS_WORKFLOW}\nJob: ${process.env.AS_JOB}\nCommit: ${process.env.AS_COMMIT}\nVersion: ${process.env.AS_VERSION}\nDNS: ${process.env.AS_DNS}\nRepository: ${process.env.AS_REPO}@${process.env.AS_REF}\nAuthor: ${process.env.AS_AUTHOR}\nStatus: ${{ job.status }}\nDuration: ${process.env.AS_TOOK}`,
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        AS_VERSION: ${{ needs.build.outputs.currentVersion }}
        AS_DNS: "https://${{ needs.build.outputs.currentENV }}.afraz.dev"
        
    - name: Run security scan on deployed application
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ secrets.DOCKER_USERNAME }}/node-app:${{ needs.build.outputs.currentVersion }}-${{ needs.build.outputs.currentENV }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'
